namespace OPS.IFSF.Generator;

internal static class Iso8583CodeTemplates
{
    #region Wrie tempalte

    public const string WriteToHeader = """
                                        // <auto-generated />
                                        using System;
                                        using System.Text;
                                        using OPS.IFSF.Abstractions.Attributes;
                                        using OPS.IFSF.Abstractions.Buffers;
                                        using OPS.IFSF.Abstractions.Models;

                                        namespace {Namespace};

                                        public partial class {ClassName}
                                        {
                                            public void WriteTo(ChunkedPooledBufferWriter writer)
                                            {
                                                var lenSpan = writer.GetSpan(4);
                                                var messageId = {MessageId};
                                                writer.Write(messageId, IsoFieldFormat.NumPad, 4);
                                                var bitMapSpan = writer.GetSpan(8);

                                        """;

    // Футер для метода WriteTo
    public const string WriteToFooter = """
                                                var messageLen = writer.TotalLength - 4;
                                                AsciiHelper.SetLength(messageLen, lenSpan);
                                            }
                                        }
                                        """;

    // Шаблон для простого поля
    public const string WriteSimpleField = """
                                                   // {Comment}
                                                   writer.Write({Prop}, {Format}, {Length});
                                                   AsciiHelper.SetBitMap({Number}, bitMapSpan);
                                           """;

    // Шаблон для nullable-поля
    public const string WriteNullableField = """
                                                     if ({Prop}.HasValue)
                                                     {
                                                         // {Comment}
                                                         writer.Write({Prop}.Value, {Format}, {Length});
                                                         AsciiHelper.SetBitMap({Number}, bitMapSpan);
                                                     }
                                             """;

    // 1) Заголовок вложенного элемента DE{Number}
    public const string WriteNestedHeader = """

                                                    // =============DE{Number} start=================
                                                    var spanDE{Number} = writer.GetSpan(3);
                                                    var startDE{Number} = writer.TotalLength;
                                                    var bitMapDE{Number} = writer.GetSpan(8);
                                            """;

    // 2) Фрагмент простого вложенного поля
    public const string WriteNestedField = """
                                                   // {Comment}
                                                   writer.Write({Prop}, {Format}, {Length});
                                                   AsciiHelper.SetBitMap({Number}, bitMapDE{ParentNumber});
                                           """;

    // 2b) Фрагмент nullable вложенного поля
    public const string WriteNestedNullableField = """
                                                           if ({Prop}.HasValue)
                                                           {
                                                               // {Comment}
                                                               writer.Write({Prop}.Value, {Format}, {Length});
                                                               AsciiHelper.SetBitMap({Number}, bitMapDE{ParentNumber});
                                                           }
                                                   """;

    // 2b) Фрагмент nullable вложенного поля
    public const string WriteNestedArrayFieldStart = """
                                                         for (int i = 0; i < {Prop}.Count; i++)
                                                         {
                                                             var item = {Prop}[i];
                                                     """;

    public const string WriteArrayFieldPart = """
                                                           writer.Write(item.{Prop}, {Format}, {Length});
                                              """;

    public const string WriteNestedArrayFieldEnd = """
                                                           }
                                                           AsciiHelper.SetBitMap({ParentNumber}, bitMapSpan);
                                                   """;

    // 3) Футер вложенного элемента
    public const string WriteNestedFooter = """
                                                    var lenDE{Number} = writer.TotalLength - startDE{Number};
                                                    AsciiHelper.SetLength(lenDE{Number}, spanDE{Number});
                                                    AsciiHelper.SetBitMap({Number}, bitMapSpan);
                                                    // =============DE{Number} end===================

                                            """;

    #endregion

    #region Read template

    // Заголовок всего метода Parse
    public const string ParseHeader = """
                                          // <auto-generated />
                                          using System;
                                          using OPS.IFSF.Abstractions.Buffers;
                                          using OPS.IFSF.Abstractions.Models;
                                          using OPS.IFSF.Abstractions.Attributes;

                                          namespace {Namespace};

                                          public partial class {ClassName}
                                          {
                                              public static {ClassName} Parse(ChunkedPooledBufferWriter writer)
                                              {
                                                  int messageId = writer.ReadInt(IsoFieldFormat.NumPad, 4);
                                                  var bitmapBytes = writer.ReadArray(IsoFieldFormat.Byte, 8);

                                                  var response = new {ClassName}();

                                                  int totalBits = bitmapBytes.Length * 8;
                                                  for (int bitIndexBE = 0; bitIndexBE < totalBits; bitIndexBE++)
                                                  {
                                                      int byteIndex   = bitIndexBE / 8;
                                                      int bitOffsetBE = bitIndexBE % 8;
                                                      byte mask       = (byte)(1 << (7 - bitOffsetBE));

                                                      if ((bitmapBytes[byteIndex] & mask) != 0)
                                                      {
                                                          int number = bitIndexBE + 1;
                                                          switch (number)
                                                          {

                                      """;

    // Простой DE
    public const string ParseSimpleField = """
                                                                   case {Number}: // DE{Number}
                                                                       response.{Prop} = writer.Read{ReadMethod}({Format}, {Length});
                                                                       break;
                                           """;

    // Начало composite DExx
    public const string ParseNestedHeader = """
                                                                    case {Number}: // DE{Number}
                                                                        // start composite DE{Number}
                                                                        var lengthDE{Number} = writer.ReadInt(IsoFieldFormat.NumPad, 3);
                                                                        var nestedBitmap{Number} = writer.ReadArray(IsoFieldFormat.Byte, 8);
                                                                        var nested{Number} = new {PropClass}();
                                                                        for (int bitIndex = 0; bitIndex < nestedBitmap{Number}.Length * 8; bitIndex++)
                                                                        {
                                                                            int byteIndexN   = bitIndex / 8;
                                                                            int bitOffsetN   = bitIndex % 8;
                                                                            byte maskN       = (byte)(1 << (7 - bitOffsetN));
                                                                            if ((nestedBitmap{Number}[byteIndexN] & maskN) != 0)
                                                                            {
                                                                                switch (bitIndex + 1)
                                                                                {
                                            """;

    // Вложенное поле composite
    public const string ParseNestedField = """
                                                                                   case {FieldNumber}: 
                                                                                       nested{ParentNumber}.{InnerProp} = writer.Read{ReadMethod}({Format}, {Length});
                                                                                       break;
                                           """;

    // Конец composite DExx
    public const string ParseNestedFooter = """
                                                                                    default:
                                                                                        throw new ArgumentOutOfRangeException(nameof(number), $"Unknown nested field DE{ParentNumber}");
                                                                                }
                                                                            }
                                                                        }

                                                                        response.{Prop} = nested{Number};
                                                                        break;
                                            """;

    // Футер всего метода Parse
    public const string ParseFooter = """
                                                              default:
                                                                  throw new ArgumentOutOfRangeException(nameof(number), $"Unsupported field DE{number}");
                                                          }
                                                      }
                                                  }

                                                  return response;
                                              }
                                          }
                                      """;


    // 2b) Неподдерживаемый простой DE
    public const string ParseUnsupportedSimpleField = """
                                                          case {Number}: // DE{Number}
                                                              throw new NotSupportedException("Unsupported type '{Type}' for DE{Number}");
                                                      """;

    // 3b) Неподдерживаемый nested DE
    public const string ParseUnsupportedNestedField = """
                                                          case {FieldNumber}: 
                                                              throw new NotSupportedException("Unsupported nested type '{Type}' for DE{ParentNumber}");
                                                      """;
    
        public const string ParseNestedArrayFieldStart = """
                                                                               case {FieldNumber}: // DE{FieldNumber} (repeating items)
                                                                                   var list{FieldNumber} = new List<{ItemType}>();
                                                                                   while (!writer.IsReadFinished())
                                                                                   {
                                                                                       var item = new {ItemType}();
                                                                            """;

    // Template for one item field assignment within the loop (for supported types)
    public const string ParseArrayFieldPart = """
                                                                                       item.{Prop} = writer.Read{ReadMethod}({Format}, {Length});
                                                                            """;

    // Template for one item field assignment if the field is a char (read string and take first char)
    public const string ParseArrayFieldPartChar = """
                                                                                       item.{Prop} = writer.ReadString({Format}, {Length})[0];
                                                                            """;

    // Template to skip the '\' delimiter after certain fields (4,5,6 in our example)
    public const string ParseArrayFieldSkipDelimiter = """
                                                                                       writer.ReadString(IsoFieldFormat.CharPad, 1); // skip delimiter
                                                                            """;

    // Template for ending the parsing of an array field: add item to list, skip item separator, assign list, and break
    public const string ParseNestedArrayFieldEnd = """
                                                                                       list{FieldNumber}.Add(item);
                                                                                       if (!writer.IsReadFinished())
                                                                                           writer.ReadString(IsoFieldFormat.CharPad, 1); // skip item delimiter '/'
                                                                                   }
                                                                                   nested{ParentNumber}.{InnerProp} = list{FieldNumber};
                                                                                   break;
                                                                            """;

    #endregion
}