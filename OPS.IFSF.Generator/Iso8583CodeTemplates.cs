namespace OPS.IFSF.Generator;

internal static class Iso8583CodeTemplates
{
    #region Wrie tempalte

    public const string WriteToHeader = """
        // <auto-generated />
        using System;
        using System.Text;
        using OPS.IFSF.Abstractions.Attributes;
        using OPS.IFSF.Abstractions.Buffers;
        using OPS.IFSF.Abstractions.Models;

        namespace {Namespace};

        public partial class {ClassName}
        {
            public void WriteTo(ChunkedPooledBufferWriter writer)
            {
                var lenSpan = writer.GetSpan(4);
                var messageId = {MessageId};
                writer.Write(messageId, IsoFieldFormat.NumPad, 4);
                var bitMapSpan = writer.GetSpan(8);

        """;

    // Футер для метода WriteTo
    public const string WriteToFooter = """
                var messageLen = writer.TotalLength - 4;
                AsciiHelper.SetLength(messageLen, lenSpan);
            }
        }
        """;

    // Шаблон для простого поля
    public const string WriteSimpleField = """
                // {Comment}
                writer.Write({Prop}, {Format}, {Length});
                AsciiHelper.SetBitMap({Number}, bitMapSpan);
        """;

    // Шаблон для nullable-поля
    public const string WriteNullableField = """
                if ({Prop}{Cond})
                {
                    // {Comment}
                    writer.Write({Prop}{Value}, {Format}, {Length});
                    AsciiHelper.SetBitMap({Number}, bitMapSpan);
                }
        """;

    // 1) Заголовок вложенного элемента DE{Number}
    public const string WriteNestedHeader = """

            // =============DE{Number} start=================
            var spanDE{Number} = writer.GetSpan(3);
            var startDE{Number} = writer.TotalLength;
            var bitMapDE{Number} = writer.GetSpan(8);
    """;

    // 2) Фрагмент простого вложенного поля
    public const string WriteNestedField = """
            // {Comment}
            writer.Write({Prop}, {Format}, {Length});
            AsciiHelper.SetBitMap({Number}, bitMapDE{ParentNumber});
    """;

    // 2b) Фрагмент nullable вложенного поля
    public const string WriteNestedNullableField = """
            if ({Prop}{Cond})
            {
                // {Comment}
                writer.Write({Prop}{Value}, {Format}, {Length});
                AsciiHelper.SetBitMap({Number}, bitMapDE{ParentNumber});
            }
    """;

    // 3) Футер вложенного элемента
    public const string WriteNestedFooter = """
            var lenDE{Number} = writer.TotalLength - startDE{Number};
            AsciiHelper.SetLength(lenDE{Number}, spanDE{Number});
            AsciiHelper.SetBitMap({Number}, bitMapSpan);
            // =============DE{Number} end===================

    """;
    #endregion

    #region Read template

    // Заголовок всего метода Parse
    public const string ParseHeader = """
        // <auto-generated />
        using System;
        using OPS.IFSF.Abstractions.Buffers;
        using OPS.IFSF.Abstractions.Models;
        using OPS.IFSF.Abstractions.Attributes;

        namespace {Namespace};

        public partial class {ClassName}
        {
            public static {ClassName} Parse(ChunkedPooledBufferWriter writer)
            {
                int messageId = writer.ReadInt(IsoFieldFormat.NumPad, 4);
                var bitmapBytes = writer.ReadArray(IsoFieldFormat.Byte, 8);

                var response = new {ClassName}();

                int totalBits = bitmapBytes.Length * 8;
                for (int bitIndexBE = 0; bitIndexBE < totalBits; bitIndexBE++)
                {
                    int byteIndex   = bitIndexBE / 8;
                    int bitOffsetBE = bitIndexBE % 8;
                    byte mask       = (byte)(1 << (7 - bitOffsetBE));

                    if ((bitmapBytes[byteIndex] & mask) != 0)
                    {
                        int number = bitIndexBE + 1;
                        switch (number)
                        {

    """;

    // Простой DE
    public const string ParseSimpleField = """
                            case {Number}: // DE{Number}
                                response.{Prop} = writer.Read{ReadMethod}({Format}, {Length});
                                break;
    """;

    // Начало composite DExx
    public const string ParseNestedHeader = """
                            case {Number}: // DE{Number}
                                // start composite DE{Number}
                                var lengthDE{Number} = writer.ReadInt(IsoFieldFormat.NumPad, 3);
                                var nestedBitmap{Number} = writer.ReadArray(IsoFieldFormat.Byte, 8);
                                var nested{Number} = new {PropClass}();
                                for (int bitIndex = 0; bitIndex < nestedBitmap{Number}.Length * 8; bitIndex++)
                                {
                                    int byteIndexN   = bitIndex / 8;
                                    int bitOffsetN   = bitIndex % 8;
                                    byte maskN       = (byte)(1 << (7 - bitOffsetN));
                                    if ((nestedBitmap{Number}[byteIndexN] & maskN) != 0)
                                    {
                                        switch (bitIndex + 1)
                                        {
    """;

    // Вложенное поле composite
    public const string ParseNestedField = """
                                            case {FieldNumber}: 
                                                nested{ParentNumber}.{InnerProp} = writer.Read{ReadMethod}({Format}, {Length});
                                                break;
    """;

    // Конец composite DExx
    public const string ParseNestedFooter = """
                                            default:
                                                throw new ArgumentOutOfRangeException(nameof(number), $"Unknown nested field DE{ParentNumber}");
                                        }
                                    }
                                }

                                response.{Prop} = nested{Number};
                                break;
    """;

    // Футер всего метода Parse
    public const string ParseFooter = """
                            default:
                                throw new ArgumentOutOfRangeException(nameof(number), $"Unsupported field DE{number}");
                        }
                    }
                }

                return response;
            }
        }
    """;


    // 2b) Неподдерживаемый простой DE
    public const string ParseUnsupportedSimpleField = """
        case {Number}: // DE{Number}
            throw new NotSupportedException("Unsupported type '{Type}' for DE{Number}");
    """;

    // 3b) Неподдерживаемый nested DE
    public const string ParseUnsupportedNestedField = """
        case {FieldNumber}: 
            throw new NotSupportedException("Unsupported nested type '{Type}' for DE{ParentNumber}");
    """;

    #endregion
}
