namespace OPS.IFSF.Generator;

internal static class Iso8583CodeTemplates
{
    #region Write template

    public static string WriteToHeader(string @namespace, string className, string messageId) => $$"""
    // <auto-generated />
    using System;
    using System.Text;
    using OPS.IFSF.Abstractions.Attributes;
    using OPS.IFSF.Abstractions.Buffers;
    using OPS.IFSF.Abstractions.Models;

    namespace {{@namespace}};

    public partial class {{className}}
    {
        public void WriteTo(ChunkedPooledBufferWriter writer)
        {
            var lenSpan = writer.GetSpan(4);
            var messageId = {{messageId}};
            writer.Write(messageId, IsoFieldFormat.NumPad, 4);
            var bitMapDE0 = writer.GetSpan(8);
    """;

    public static string WriteToFooter() => """
                var messageLen = writer.TotalLength - 4;
                AsciiHelper.SetLength(messageLen, lenSpan);
            }
        }
        """;

    public static string WriteField(int number, string prop, string format, int length, string comment, string parentNumber) => $"""
            // {comment}
            writer.Write({prop}, {format}, {length});
            AsciiHelper.SetBitMap({number}, bitMapDE{parentNumber});
    """;

    public static string WriteNullableField(int number, string prop, string format, int length, string comment, string parentNumber, string condition, string valueAccess) => $$"""
            if ({{prop}}{{condition}})
            {
                // {{comment}}
                writer.Write({{prop}}{{valueAccess}}, {{format}}, {{length}});
                AsciiHelper.SetBitMap({{number}}, bitMapDE{{parentNumber}});
            }
    """;

    public static string WriteNestedHeader(int number) => $"""

            // =============DE{number} start=================
            var spanDE{number} = writer.GetSpan(3);
            var startDE{number} = writer.TotalLength;
            var bitMapDE{number} = writer.GetSpan(8);
    """;

    public static string WriteNestedFooter(int number) => $"""
            var lenDE{number} = writer.TotalLength - startDE{number};
            AsciiHelper.SetLength(lenDE{number}, spanDE{number});
            AsciiHelper.SetBitMap({number}, bitMapDE0);
            // =============DE{number} end===================

    """;

    #endregion

    #region Parse template

    public static string ParseHeader(string @namespace, string className) => $$"""
    // <auto-generated />
    using System;
    using OPS.IFSF.Abstractions.Buffers;
    using OPS.IFSF.Abstractions.Models;
    using OPS.IFSF.Abstractions.Attributes;

    namespace {{@namespace}};

    public partial class {{className}}
    {
        public static {{className}} Parse(ChunkedPooledBufferWriter writer)
        {
            int messageId = writer.ReadInt(IsoFieldFormat.NumPad, 4);
            var bitmapBytes = writer.ReadArray(IsoFieldFormat.Byte, 8);

            var response = new {{className}}();

            int totalBits = bitmapBytes.Length * 8;
            for (int bitIndexBE = 0; bitIndexBE < totalBits; bitIndexBE++)
            {
                int byteIndex   = bitIndexBE / 8;
                int bitOffsetBE = bitIndexBE % 8;
                byte mask       = (byte)(1 << (7 - bitOffsetBE));

                if ((bitmapBytes[byteIndex] & mask) != 0)
                {
                    int number = bitIndexBE + 1;
                    switch (number)
                    {
    """;

    public static string ParseFooter() => """
                        default:
                            throw new ArgumentOutOfRangeException(nameof(number), $"Unsupported field DE{number}");
                    }
                }
            }

            return response;
        }
    }
    """;

    public static string ParseField(int number, string prop, string target, string readMethod, string format, int length) => $"""
                        case {number}: // DE{number}
                            {target}.{prop} = writer.Read{readMethod}({format}, {length});
                            break;
    """;

    public static string ParseUnsupportedField(int number, string prop, string type) => $"""
                        case {number}: // DE{number}
                            throw new NotSupportedException("Unsupported field: DE{number} → property '{prop}' (type: {type})");
    """;

    public static string ParseNestedHeader(int number, string propClass) => $$"""
                        case {{number}}: // DE{{number}}
                            // start composite DE{{number}}
                            var lengthDE{{number}} = writer.ReadInt(IsoFieldFormat.NumPad, 3);
                            var nestedBitmap{{number}} = writer.ReadArray(IsoFieldFormat.Byte, 8);
                            var nested{{number}} = new {{propClass}}();
                            for (int bitIndex = 0; bitIndex < nestedBitmap{{number}}.Length * 8; bitIndex++)
                            {
                                int byteIndexN   = bitIndex / 8;
                                int bitOffsetN   = bitIndex % 8;
                                byte maskN       = (byte)(1 << (7 - bitOffsetN));
                                if ((nestedBitmap{{number}}[byteIndexN] & maskN) != 0)
                                {
                                    switch (bitIndex + 1)
                                    {
    """;

    public static string ParseNestedFooter(int parentNumber, string prop, int number) => $$"""
                                        default:
                                            throw new ArgumentOutOfRangeException(nameof(number), $"Unknown nested field DE{{parentNumber}}");
                                    }
                                }
                            }

                            response.{{prop}} = nested{{number}};
                            break;
    """;

    #endregion
}
