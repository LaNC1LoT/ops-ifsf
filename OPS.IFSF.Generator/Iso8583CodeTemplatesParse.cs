namespace OPS.IFSF.Generator;

internal class Iso8583CodeTemplatesParse
{
    public static string ParseHeader(string @namespace, string className) => $$"""
    // <auto-generated />
    using System;
    using OPS.IFSF.Abstractions.Buffers;
    using OPS.IFSF.Abstractions.Models;
    using OPS.IFSF.Abstractions.Attributes;

    namespace {{@namespace}};

    public partial class {{className}}
    {
        public static {{className}} Parse(ChunkedPooledBufferWriter writer)
        {
            int messageId = writer.ReadInt(IsoFieldFormat.NumPad, 4);
            var bitmapBytes = writer.ReadArray(IsoFieldFormat.Byte, 8);

            var response = new {{className}}();

            int totalBits = bitmapBytes.Length * 8;
            for (int bitIndexBE = 0; bitIndexBE < totalBits; bitIndexBE++)
            {
                int byteIndex   = bitIndexBE / 8;
                int bitOffsetBE = bitIndexBE % 8;
                byte mask       = (byte)(1 << (7 - bitOffsetBE));

                if ((bitmapBytes[byteIndex] & mask) != 0)
                {
                    int number = bitIndexBE + 1;
                    switch (number)
                    {
    """;

    public static string ParseFooter(string nestedMethods) => $$"""
                        default:
                            throw new ArgumentOutOfRangeException(nameof(number), $"Unsupported field DE{number}");
                    }
                }
            }

            return response;
        }

    {{nestedMethods}}
    }
    """;

    public static string ParseField(int number, string prop, string target, string readMethod, string format, int length, string? extentions = null) => $"""
                        case {number}: // DE{number}
                            {extentions}
                            {target}.{prop} = writer.Read{readMethod}({format}, {length});
                            break;
    """;

    public static string ParseUnsupportedField(int number, string prop, string type) => $"""
                        case {number}: // DE{number}
                            throw new NotSupportedException("Unsupported field: DE{number} → property '{prop}' (type: {type})");
    """;

    public static string ParseNestedCall(int number, string prop) => $"""
                        case {number}: // DE{number}
                            response.{prop} = ParseDE{number}(writer);
                            break;
    """;

    public static string ParseNestedMethod(int number, string propClass, IEnumerable<string> nestedSwitches) => $$"""
        private static {{propClass}} ParseDE{{number}}(ChunkedPooledBufferWriter writer)
        {
            var length = writer.ReadInt(IsoFieldFormat.NumPad, 3);
            var bitmap = writer.ReadArray(IsoFieldFormat.Byte, 8);
            var nested = new {{propClass}}();

            for (int bitIndex = 0; bitIndex < bitmap.Length * 8; bitIndex++)
            {
                int byteIndex = bitIndex / 8;
                int bitOffset = bitIndex % 8;
                byte mask = (byte)(1 << (7 - bitOffset));

                if ((bitmap[byteIndex] & mask) != 0)
                {
                    int number = bitIndex + 1;
                    switch (number)
                    {
    {{string.Join("\n", nestedSwitches)}}
                        default:
                            throw new ArgumentOutOfRangeException(nameof(number), "Unknown nested field DE{{number}}");
                    }
                }
            }

            return nested;
        }
    """;

    public static string ParseNestedMethodWithoutBitmap(int number, string propClass, IEnumerable<string> fieldParsers) => $$"""
              private static {{propClass}} ParseDE{{number}}(ChunkedPooledBufferWriter writer)
              {
                  var length = writer.ReadInt(IsoFieldFormat.NumPad, 3);
                  var endOffset = writer.GetCurrentOffset() + length;

                  var nested = new {{propClass}}();
                  for (int fieldNumber = 1; !writer.IsReadFinished() && writer.GetCurrentOffset() < endOffset; fieldNumber++)
                  {
                      switch (fieldNumber)
                      {
          {{string.Join("\n", fieldParsers)}}
                          default:
                              throw new ArgumentOutOfRangeException(nameof(fieldNumber), "Unknown nested field DE{{number}}");
                      }
                  }

                  return nested;
              }
          """;

    public const string ParseNestedArrayFieldStart = $$"""
                        case {FieldNumber}: // DE{FieldNumber} (repeating items)
                            var list{FieldNumber} = new List<{ItemType}>();
                            while (!writer.IsReadFinished())
                            {
                                var item = new {ItemType}();
                                int nestedFieldNumber = 1;
                                while (!writer.IsReadFinished())
                                {
                                    switch (nestedFieldNumber)
                                    {
    """;

    public const string ParseArrayFieldSkipDelimiter = $$"""
                                        writer.ReadString(IsoFieldFormat.CharPad, 1); // skip delimiter
    """;

    public const string ParseNestedArrayFieldEnd = $$"""
                                        default:
                                            throw new ArgumentOutOfRangeException(nameof(nestedFieldNumber), $"Unsupported field DE{FieldNumber}");
                                    }
                                    nestedFieldNumber++;
                                }

                                list{FieldNumber}.Add(item);

                                if (!writer.IsReadFinished())
                                    writer.ReadString(IsoFieldFormat.CharPad, 1); // skip item delimiter '/'
                            }

                            nested.{InnerProp} = list{FieldNumber};
                            break;
    """;
}
